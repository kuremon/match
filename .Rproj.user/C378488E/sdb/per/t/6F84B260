{
    "contents" : "#' @title Interactive partial match \n#' @description Search for partial matching between values and propose multiple choice to the user \n#' @param search.that The values to search for.\n#' @param in.that Where the values should be matched to.\n#' @param ... Additional arguments to \\code{\\link{agrep}}.\n#' @return The index in \\code{in.that} corresponding to the ones in \\code{search.that}.\n#' @details Press q to exit the process midway.\n#' @export\n#' @examples\n#' \\donttest{\n#' search.that=c(\"volvo\",\"toyota\")\n#' in.that=row.names(mtcars)\n#' match=imatch(search.that,in.that)\n#' }\nimatch=function(search.that,in.that,...,perfect.match=TRUE){\n  if(anyDuplicated(in.that)) warning(\"Duplicates are present in the reference vector.\")\n  \n  if(perfect.match){\n    match=match(search.that,in.that)\n  }else{\n    match=rep(NA_integer_,length(search.that))\n  }\n  \n  for(k in which(is.na(match))){\n    str=search.that[[k]]\n    result=agrep(str,in.that,...)\n    l.result=length(result)\n    if(l.result==0){\n      message(str,\" could not be matched.\")\n    }else{\n      message(str,\" :\")\n      cat(\"NA\",fill=TRUE,labels=paste0(\"{\",0,\"}:\"))\n      for(j in seq(1,l.result)){\n        cat(in.that[[result[j]]],fill=TRUE,labels=paste0(\"{\",j,\"}:\"))\n      }\n      int=readline(\"So ...? \")\n      if(int==\"q\"){\n        warning(\"imatch was exited midway.\")\n        return(match)\n      }\n      int=as.integer(int)\n      if((1<=int)&(int<=l.result))match[k]=result[int]\n    }\n  }\n  match\n}\n\n#' @title Interactive mapping \n#' @description Map values interactively to a reference\n#' @param map.that The values to map.\n#' @param to.that Reference values to map to.\n#' @param unique.mapping Should the relationship be one to one.\n#' @param perfect.match Should the matching be perfect.\n#' @return The values in \\code{map.that} mapped to the ones \\code{to.that}.\n#' @details Press q to exit the process midway.\n#' @export\n#' @examples\n#' \\donttest{\n#' map.that=c(\"volvo\",\"toyota\")\n#' to.that=row.names(mtcars)\n#' map=imap(map.that,to.that)\n#' }\nimap=function(map.that,to.that,unique.mapping=TRUE,perfect.match=TRUE){\n  if(anyDuplicated(to.that)) warning(\"Duplicates are present in the reference vector.\")\n  \n  if(perfect.match){\n    map=match(map.that,to.that)\n  }else{\n    map=rep(NA_integer_,length(map.that))\n  }\n  \n  prop=seq(to.that)\n  for(k in which(is.na(map))){\n    str=map.that[[k]]\n    l.prop=length(prop)\n    if(l.prop==0){\n      message(str,\" could not be matched.\")\n    }else{\n      message(str,\" :\")\n      cat(\"NA\",fill=TRUE,labels=paste0(\"{\",0,\"}:\"))\n      for(j in seq(1,l.prop)){\n        cat(to.that[[prop[j]]],fill=TRUE,labels=paste0(\"{\",j,\"}:\"))\n      }\n      int=readline(\"So ...? \")\n      if(int==\"q\"){\n        warning(\"imatch was exited midway.\")\n        return(map)\n      }\n      int=as.integer(int)\n      if((1<=int)&(int<=l.prop)){\n        map[k]=prop[int]\n        if(unique.mapping)prop=prop[-int]\n      }\n    }\n  }\n  map\n}",
    "created" : 1381292292749.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3984702060",
    "id" : "6F84B260",
    "lastKnownWriteTime" : 1384310392,
    "path" : "~/R&D/R packages/Source packages/match/R/imatch.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}